// 声明全局符号，对应x86-64的.globl
.globl co_ctx_swap

// ARM64汇编中，函数标签直接定义，无需额外关键字
co_ctx_swap:
    // 第一部分：保存当前协程上下文到 x0 指向的内存区域
    // 关键修正：通过x10中转存储sp（栈指针），避免直接操作sp
    mov x10, sp          // 1. 先将sp的值赋值给通用寄存器x10（中转）
    str x10, [x0, #104]  // 2. 存储x10的值（即sp的值）到内存，解决直接操作sp的报错
    str x19, [x0, #96]   // 保存被调用者保存寄存器 x19
    str x20, [x0, #88]   // 保存 x20
    str x21, [x0, #80]   // 保存 x21
    str x22, [x0, #72]   // 保存 x22
    str x23, [x0, #64]   // 保存 x23
    str x24, [x0, #56]   // 保存 x24
    str x25, [x0, #48]   // 保存 x25
    str x26, [x0, #40]   // 保存 x26
    str x27, [x0, #32]   // 保存 x27
    str x28, [x0, #24]   // 保存 x28
    str x29, [x0, #16]   // 保存 x29（帧指针）
    str lr,  [x0, #8]    // 保存返回地址 lr（x30）
    str x30, [x0, #0]    // 保存 x30

    // 第二部分：从 x1 指向的内存区域恢复目标协程上下文
    ldr x30, [x1, #0]    // 恢复 x30
    ldr lr,  [x1, #8]    // 恢复返回地址 lr
    ldr x29, [x1, #16]   // 恢复帧指针 x29
    ldr x28, [x1, #24]   // 恢复 x28
    ldr x27, [x1, #32]   // 恢复 x27
    ldr x26, [x1, #40]   // 恢复 x26
    ldr x25, [x1, #48]   // 恢复 x25
    ldr x24, [x1, #56]   // 恢复 x24
    ldr x23, [x1, #64]   // 恢复 x23
    ldr x22, [x1, #72]   // 恢复 x22
    ldr x21, [x1, #80]   // 恢复 x21
    ldr x20, [x1, #88]   // 恢复 x20
    ldr x19, [x1, #96]   // 恢复 x19
    // 关键修正：通过x10中转恢复sp（栈指针），避免直接操作sp
    ldr x10, [x1, #104]  // 1. 先从内存加载栈指针值到x10（中转）
    mov sp, x10          // 2. 将x10的值赋值给sp，完成栈指针恢复

    // ARM64 ret 伪指令（本质br lr），完成上下文切换返回
    ret